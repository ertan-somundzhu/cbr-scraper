import pandas as pd  
from tqdm import tqdm  
from tqdm.auto import tqdm
import time  
from bs4 import BeautifulSoup  
import requests
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from datetime import date
from datetime import timedelta
import datetime
import pymorphy3 
morph = pymorphy3.MorphAnalyzer()
from joblib import Parallel, delayed
from pypdf import PdfWriter 
import os

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.by import By 
from selenium.webdriver.common.keys import Keys  
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.remote.webelement import WebElement

options = Options()
options.add_argument("start-maximized") 
wb = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options) 


def get_cbr_website(link_cbr = "https://www.cbr.ru/"):

    """This function opens and clicks through CBR's website's pages, emulating a real user"""

    wb.get(link_cbr)
    time.sleep(3)
    
    menu = wb.find_element(By.XPATH, "/html/body/header/div[5]/div/div/div[1]/div/div[1]/div/div")
    menu.click()
    time.sleep(3)
    
    documents_data = wb.find_element(By.XPATH, "/html/body/div[2]/div/div[3]/div[1]/div[1]/a[3]")
    documents_data.click()
    time.sleep(3)
    
    data_base = wb.find_element(By.XPATH, "/html/body/div[2]/div/div[3]/div[5]/div/ul[2]/li[8]/a")
    data_base.click()
    time.sleep(3)

    return "Success"


def get_history_excahnge_rate(number_id = 3) -> pd.core.frame.DataFrame:

    """
    This function clicks through CBR's website's pages, emulating a real user (similar to get_cbr_website())
    
    Fills a pandas DataFrame with the following data: 
    1) numerical code of a currency
    2) letter code of a currency
    3) currency name
    4) units of currency  
    5) rate of a ruble 
    6) rate of a ruble to one unit of currency
    
    It goes through a list of links, generated by exchange_link_generator()

    After the DataFrame is filled and returned
    """
    
    get_cbr_website()
    time.sleep(2)

    wb.find_element(By.XPATH, "/html/body/main/div/div/div/div[1]/div[3]/div/div[2]/div/div/a/span").click()
    time.sleep(2.5)    

    wb.find_element(By.XPATH, "/html/body/main/div/div/div/div[2]/div[1]/div/div[2]/div/div/a/span").click()
    time.sleep(3)

    num_code_name = wb.find_element(By.XPATH, "/html/body/main/div/div/div/div[3]/div/table/tbody/tr[1]/th[1]").text
    letter_code_name = wb.find_element(By.XPATH, "/html/body/main/div/div/div/div[3]/div/table/tbody/tr[1]/th[2]").text
    num_name = wb.find_element(By.XPATH, "/html/body/main/div/div/div/div[3]/div/table/tbody/tr[1]/th[3]").text
    curr_name_name = wb.find_element(By.XPATH, "/html/body/main/div/div/div/div[3]/div/table/tbody/tr[1]/th[4]").text
    rate_name = wb.find_element(By.XPATH, "/html/body/main/div/div/div/div[3]/div/table/tbody/tr[1]/th[5]").text
    rate_to_one_name = "Курс к одному"
    date_name = "Дата"
    df = pd.DataFrame({
        num_code_name: [], letter_code_name: [], curr_name_name: [], num_name: [], rate_name: [], 
        rate_to_one_name: [],  date_name: []
    })
    
    def data_finder():
        cnt = 2
        while True:
            try:
                num_code = int(wb.find_element(By.XPATH, f"/html/body/main/div/div/div/div[3]/div/table/tbody/tr[{cnt}]/td[1]").text)
                letter_code = wb.find_element(By.XPATH, f"/html/body/main/div/div/div/div[3]/div/table/tbody/tr[{cnt}]/td[2]").text
                num = int(wb.find_element(By.XPATH, f"/html/body/main/div/div/div/div[3]/div/table/tbody/tr[{cnt}]/td[3]").text)
                curr_name = wb.find_element(By.XPATH, f"/html/body/main/div/div/div/div[3]/div/table/tbody/tr[{cnt}]/td[4]").text
                rate = wb.find_element(By.XPATH, f"/html/body/main/div/div/div/div[3]/div/table/tbody/tr[{cnt}]/td[5]").text
                if "-" not in rate:
                    rate = float(rate.replace(",", ".")) 
                    rate_to_one = rate / num
                else:
                    rate = "NaN"
                    rate_to_one = rate
                yield [num_code, letter_code, curr_name, num, rate, rate_to_one]
                cnt += 1
            except: 
                break


    links_df_to_list = exchange_link_generator()["Ссылки"].tolist()
    dates_links_df_to_list = exchange_link_generator()["Дата"].tolist()
    
    for link in tqdm(links_df_to_list, desc = "data gathering"):

        try:
            wb.get(link)
            time.sleep(2)
    
            num_code_list, letter_code_list, curr_name_list, num_list, rate_list, rate_to_one_list, dates_list = [], [], [], [], [], [], []
    
            for elem in data_finder():
                num_code_list.append(elem[0])
                letter_code_list.append(elem[1])
                curr_name_list.append(elem[2])
                num_list.append(elem[3])
                rate_list.append(elem[4])
                rate_to_one_list.append(elem[5])
                dates_list.append(dates_links_df_to_list[links_df_to_list.index(link)])
            
            sub_df = pd.DataFrame({
                num_code_name: num_code_list, letter_code_name: letter_code_list, 
                curr_name_name: curr_name_list, num_name: num_list, 
                rate_name: rate_list, rate_to_one_name: rate_to_one_list,
                date_name: dates_list
            })
    
            df = pd.concat([df, sub_df], ignore_index = True)
        except:
            pass
    
    return df



def noun_sing_exceptions(sentence: list) -> str:
    sentence = " ".join(sentence).split(" FLAG")[0]
    correct_form = {"мар": lambda x: morph.parse(morph.parse(x.split()[0])[0].normal_form)[0].inflect({"sing", "femn", "nomn"}).word.capitalize() + " марка", 
                    "лир": lambda x: morph.parse(morph.parse(x.split()[0])[0].normal_form)[0].inflect({"sing", "femn", "nomn"}).word.capitalize() + " лира", 
                    "Вон": lambda x: "Вона Республики Корея", 
                    "манат": lambda x: "Новый туркменский манат" if len(x.split()) == 3 else "Азербайджанский манат", 
                    "СДР": lambda x: "СДР (специальные права заимствования)", 
                    "сомон": lambda x: "Таджикский сомони", "тенге": lambda x: "Казахстанский тенге",
                    "драм": lambda x: "Армянский драм", "стерл": lambda x: "Фунт стерлингов Соединенного Королевства"}
    for k, v in correct_form.items():
        if k in sentence:
            return v(sentence)



def word_gender_morphing(word_pair: str) -> str:
    word_pair = word_pair.split()
    if len(word_pair) != 1:
        if "FLAG" not in word_pair:
            if morph.parse(word_pair[0])[0].tag.POS == "ADJF":
                if morph.parse(word_pair[1])[0].tag.gender ==  "masc":
                    new_adj = morph.parse(morph.parse(word_pair[0])[0].normal_form)[0].inflect({"sing", "masc", "nomn"}).word
                elif morph.parse(word_pair[1])[0].tag.gender ==  "femn":
                    new_adj = morph.parse(morph.parse(word_pair[0])[0].normal_form)[0].inflect({"sing", "femn", "nomn"}).word
                elif morph.parse(word_pair[1])[0].tag.gender ==  "neut":
                    new_adj = morph.parse(morph.parse(word_pair[0])[0].normal_form)[0].inflect({"sing", "neut", "nomn"}).word
                return " ".join([new_adj, word_pair[1]]).capitalize()
            else:
                return " ".join(word_pair).capitalize()
        else:
            return noun_sing_exceptions(word_pair)
    return " ".join(word_pair).capitalize()



def noun_sing(sentence: str) -> str:
    sentence = sentence.split()        
    if True in [i in " ".join(sentence) for i in ["мар", "драм", "лир", "Вон", "сом", "манат", "СДР", "сомон", "тенге", "стерл"]]:
        sentence = " ".join(sentence) + " FLAG"
        return sentence
    elif morph.parse(sentence[0])[0].tag.POS == "NOUN":
        sentence[0] = morph.parse(sentence[0])[0].inflect({"sing", "nomn"}).word
        return " ".join(sentence)
    elif morph.parse(sentence[1])[0].tag.POS == "NOUN":            
        sentence[1] = morph.parse(sentence[1])[0].inflect({"sing", "nomn"}).word
        return " ".join(sentence)        
        


def converter(sentence: str) -> str:
    return word_gender_morphing(noun_sing(sentence))


def name_cleaner(history_exchange_rate_df):

    """This function inflects singular form onto the name of currecies by using converter() (which uses noun_sing() and word_gender_morphing() (and noun_sing_exceptions() for exceptions))"""
    
    clean_names_list = Parallel(n_jobs = 4)(delayed(converter)(sentence) for sentence in tqdm(history_exchange_rate_df["Валюта"], desc = "name cleaner"))
    clean_names_df = pd.DataFrame({"Валюта и.п.": clean_names_list})
    return clean_names_df


def fluct_graph(i, full_df):

    """This function plots changes in exchange value for onr currency and saves it as a pdf file"""
    
    one_currency_df = full_df[full_df["Букв. код"] == full_df["Букв. код"].unique()[i]].reset_index()
    plt.figure()
    plt.title(f"Изменение курса с {one_currency_df["Дата"][0]} по {one_currency_df["Дата"][len(one_currency_df) - 1]}")
    plt.plot(one_currency_df["Дата"].apply(lambda x: datetime.datetime(int(x.split(".")[2]), int(x.split(".")[1]), int(x.split(".")[0]))), one_currency_df["Курс к одному"])
    plt.ylabel(f"Курс (руб. за ед. валюты)")
    plt.xlabel("Дата")
    plt.xticks(rotation=70)
    plt.gca().legend(one_currency_df["Букв. код"])
    plt.savefig(f"graph{i}.pdf", format='pdf')
    plt.close()

def plot_to_pdf(full_df):

    """
    This gunction creates pdf of plots, merges them into one single pdf file and then deletes pdf files with single files
    """
    
    for i, curr in tqdm(enumerate(full_df["Букв. код"].unique()), desc = "plot generator"):
        fluct_graph(i, full_df)
       
    pdfs = [f"graph{i}.pdf" for i in range(len(full_df["Букв. код"].unique()))]
    
    merger = PdfWriter()
    
    for pdf in tqdm(pdfs, desc = "pdf generator"):
        merger.append(pdf)
    
    merger.write("currency_fluct.pdf")
    merger.close()
    
    for pdf in tqdm(pdfs, desc = "plot files cleaner"):
        os.remove(pdf)


def get_everything_big_wrapper_func():

    """This wrapper function return two Excel files and a pdf file"""
    
    history_exchange_rate_df = get_history_excahnge_rate()
    history_exchange_rate_df.to_excel("exchange_hisroty_cbr_pre.xlsx")
    
    full_df = history_exchange_rate_df.join(name_cleaner(history_exchange_rate_df))
    full_df = full_df[["Цифр. код", "Букв. код", "Валюта и.п.", "Единиц", "Курс", "Курс к одному", "Дата", "Валюта"]]
    full_df.to_excel("exchange_hisroty_cbr.xlsx")
    
    plot_to_pdf(full_df)  


get_everything_big_wrapper_func()
